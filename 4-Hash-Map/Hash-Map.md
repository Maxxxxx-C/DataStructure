
# 第四章 散列表（Hash Map）

## 4.1 基础数据结构概念

### 4.1.1 动态集合

将在运算过程中会发生改变的集合成为动态集合，记为 $S$，动态集合有自己的元素及自己的操作方式。不同的算法可能对集合执行不同的操作。

### 4.1.2 动态集合的元素

在动态集合 S 中，每一个元素通过一个对象来表示，每个对象都有自己的若干属性；如果有一个指向对象的指针 $x$，就能对其各个属性进行检查和操作。

为了方便，将 x 指向的元素直接记作 $x$，将 x 指向的元素属于 S 直接记作 $x\in S$。对于 x 包含的一个属性 a，记作 `x->a` 或者 `x.a` 或者 `a[x]`。

虽然称 x 为指针，但这和 C 语言里的指针概念并不相同，它代表的是一个索引，表示我们可以通过 x 来访问 x 指向的元素；x 可以是数组里的下标，可以是 C 语言里的指针，也可以是 Java 里的引用。

在一般的动态集合的实现里，x 会包含一个属性叫做`关键字`(key)，key 是 S 对集合进行增加、删除、查找等操作的关键属性；有些属性在集合的操作中一直跟着其他属性移动，但操作本身不使用它们，这些属性叫做`卫星数据`(satellite data)

### 4.1.3 动态集合的操作

动态集合的操作包括简单返回集合元素的`查询操作`和改变的`修改操作`，下面是一些操作：

`修改操作`

- **Insert(S, x)**: 将 x 加入集合 S
- **Delete(S, x)**: 从集合 S 中删除元素 x

`查询操作`

- **Search(S, k)**: 给定关键字 k，在集合 S 中寻找元素 x 使得 x->key=k，并返回 x；若没有 x 满足该条件，则返回 nil

一些关于全序集的操作，例如链表：

数据结构中的顺序一般由关键字 key 的大小决定

- **Minimum(S)**: 给定全序集 S，返回最小元素
- **Maximum(S)**: 给定全序集 S，返回最大元素
- **Successor(S, x)**: 给定全序集 S 中的元素 x，返回比 x 大的第一个元素；若 x 是最大元素，则返回 nil
- **Predecessor(S, x)**: 给定全序集 S 中的元素 x，返回比 x 小的第一个元素；若 x 是最小元素，则返回 nil

## 4.2 直接映射表

所有的 key 构成了一个集合 K，并且 K 有全集 U={0, 1, 2,..., m-1}，假设这些 key 相互独立

建立一个表 T[0...m-1] 来表示一个动态集合 S，这个表可以表示为

$$T[k]=x,\ if\ x\in S \And\ x\to key=k$$

否则

$$T[k]=nil$$

1. Insert(S, x): T[x->key]=x
2. Delete(S, x): T[x->key]=nil
3. Search(S, k): return T[k]

所有这些操作的时间消耗为 $O(1)$，但是空间消耗非常的大，假设每个元素是一个长度为 32 的数，假设你只需要 10 个元素，也需要开辟一个 40G 的空间。

## 4.3 链接法

### 4.3.1 散列表基础

散列表，也称为哈希表，指用一个散列函数 $h$，将集合 $K$ 的全集 $U$ 映射到散列表 $T[0...m-1]$ 的槽位中，即

$$h:U\to[0,m-1]$$

此时散列表可以表示为

$$T[h(k)]=x,\ if\ x\in S \And\ x\to key=k$$

否则

$$T[h(k)]=nil$$

由于散列表的大小 $m$ 要比 $\left | U \right | $ 小得多，因此一定存在两个互相独立的 key 映射到表中的同一个槽位，把这种情况称为`碰撞`

可以简单地为每一个槽创建一个链表，并且把发生碰撞的元素放入同一个链表，这种方法叫做`链接法`。

### 4.3.2 简单均匀散列

当所有元素都映射到了散列表的同一个槽，将是非常糟糕的，因为你将浪费大部分空间同时使得各种的速度变慢，时间消耗为 $O(n)$。在最坏情况下，有很多数据结构比散列表工作得更好，但是散列表的平均时间消耗仍然是最好的。

假设存在一个理想的散列函数 $h$，使得 $\forall x \in S$，$x\to k$ 能均匀地映射到大小为 $m$ 的散列表 $T$ 的所有槽中，其中每个 $key$ 与已经存在于表中的 $key$ 相互独立。

$$\Pr(h(k)=i)=\frac{1}{m},i\in[0,m-1]$$

定义一个存放 $n$ 个键，有 $m$ 个槽的散列表，定义它的装载因子为 $\alpha=n/m$，$\alpha$ 表示这个散列表的平均装载量。

假设寻找一个并不在表内的键，则时间消耗包括计算散列值和查找链表。计算散列值的时间消耗为 $\Theta(1)$，每个链表的平均长度为 $\alpha$，所以查找链表的时间消耗为 $\Theta(\alpha)$，总的时间消耗为 $\Theta(1+\alpha)$，当 $n=O(m)$时，$O(\alpha)=O(1)$，此时搜索时间消耗为常数 $O(1)$

**定理**：在简单均匀散列的假设下，对于用链接法解决冲突的散列表，一次成功查找所需的平均时间为 $\Theta(1+\alpha)$

### 4.3.3 两种散列函数

一个好的散列函数要满足以下几点：

- 可以让所有元素均匀地分配到散列表中
- 不同的键集合不影响其分配的均匀性

#### 除法散列法

$$h(k)=k\ mod\ m$$

- 不要选择一个太小的 $m$ 来做除数

$e.g.$ 选择 $m=2$ 同时所有 $k$ 都是偶数

- 不要选择偶数 $m$ 来做除数

$e.g.$ 选择 $m=16$ 同时所有 $k$ 都是偶数

因为偶数除以偶数余数也是偶数，此时散列表中所有的奇数位永远为空

- 不要选择 $m=2^r$ 来做除数

此时 $h(k)$ 就是 $k$ 的 $r$ 个最低位数字

最好的方法是使用质数作为除数，同时该质数需要远离 $2$ 和 $10$ 的幂

#### 乘法散列法

假设 $m=2^r$，以及计算机的一个字的长度是 $w$ 位

$$h(k)=(A\cdot k\ mod\ 2^w)rsh(w-r)$$

首先将 $k$ 乘以一个大于 $2^{w-1}$ 且小于 $2^{w}$ 的奇数 $A$，然后对 $2^w$ 取模，然后右移 $w-r$ 位

- 不要选择太接近 $2^r$ 的值做为 $A$

## 4.4 开放寻址法

开放寻址法不使用链表解决碰撞，它通过不断地散列直到找到一个空位置

$$h:U\times[0,m-1]\to[0,m-1]$$

定义域是全集 $U$ 与探查序列（第几次散列）$[0,m-1]$ 的笛卡尔积，陪域是散列表的槽位

探查序列是一个算术序列

开放寻址最终会被填满，因此要保证 $n\leqslant m$，这样散列表才不会溢出

### 4.4.1 线性探查序列

$$h(k,i)=(h'(k)+i)\ mod\ m$$

$h'(k)$ 称为辅助散列函数

当一个槽被占用时，这个函数会递归地走到下一个槽并检查

**一次群集问题**：散列表可能出现长度为 $m'$ 的连续区域，这片连续区域都被占满，这使得每次插入操作都会遍历这片连续区域，将显著增加时间消耗

为了解决这个问题，可以通过修改成以下函数来缓解

$$h(k,i)=(h_1(k)+i\cdot h_2(k))\ mod\ m$$

通常取 $m=2^r$ 同时 $h_2(k)$ 为奇数

### 4.4.2 时间消耗计算

假设探查序列能遍历 $<0,1,...,m-1>$ 中的所有值，遍历的过程是 $<0,1,...,m-1>$ 的一个排列，每个键都均等地有 $m!$ 种探查序列，并且每个键是相互独立的。

**定理**：当 $\alpha<1$时，预期的探查次数最多不超过 $1/(1-\alpha)$

如果有 $n$ 个元素装在大小为 $m$ 的散列表里

假设这次是失败搜索，因此 $i=0$ 时一定会撞上一个非空槽，那之后 $i=1$ 时的搜索撞上一个非空槽的概率为 $n/m$，$i=2$ 时的搜索撞上一个非空槽的概率为 $(n-1)/(m-1)$，则有 $i=k$ 时的搜索撞上一个非空槽的概率为

$$\Pr(i=k\ \text{时撞上非空槽})=\frac{n-k-1}{m-k-1}$$

且有

$$\frac{n-k}{m-k}<\frac{n}{m}=\alpha$$

求碰撞次数的期望是

$$E[collision]=1+\frac{n}{m}(1+\frac{n-1}{m-1}(1+\frac{n-2}{m-2}(...(1+\frac{1}{m-n}))))$$

$$\leqslant 1+\alpha(1+\alpha(1+\alpha(...(1+\alpha))))$$

$$= 1+\alpha+\alpha^2+\alpha^3+...$$

$$= \sum_{i=0}^{\infty}\alpha^i$$

$$= \frac{1}{1-\alpha}$$

这意味着探查这个表的平均时间消耗是 $O(1)$

## 4.5 全域散列和完全散列

---

---

---

---

---

---
