
# 第四章 散列表（Hash Map）

## 4.1 基础数据结构概念

### 4.1.1 动态集合

将在运算过程中会发生改变的集合成为动态集合，记为 $S$，动态集合有自己的元素及自己的操作方式。不同的算法可能对集合执行不同的操作。

### 4.1.2 动态集合的元素

在动态集合 S 中，每一个元素通过一个对象来表示，每个对象都有自己的若干属性；如果有一个指向对象的指针 $x$，就能对其各个属性进行检查和操作。

为了方便，将 x 指向的元素直接记作 $x$，将 x 指向的元素属于 S 直接记作 $x\in S$。对于 x 包含的一个属性 a，记作 `x->a` 或者 `x.a` 或者 `a[x]`。

虽然称 x 为指针，但这和 C 语言里的指针概念并不相同，它代表的是一个索引，表示我们可以通过 x 来访问 x 指向的元素；x 可以是数组里的下标，可以是 C 语言里的指针，也可以是 Java 里的引用。

在一般的动态集合的实现里，x 会包含一个属性叫做`关键字`(key)，key 是 S 对集合进行增加、删除、查找等操作的关键属性；有些属性在集合的操作中一直跟着其他属性移动，但操作本身不使用它们，这些属性叫做`卫星数据`(satellite data)

### 4.1.3 动态集合的操作

动态集合的操作包括简单返回集合元素的`查询操作`和改变的`修改操作`，下面是一些操作：

`修改操作`

- **Insert(S, x)**: 将 x 加入集合 S
- **Delete(S, x)**: 从集合 S 中删除元素 x

`查询操作`

- **Search(S, k)**: 给定关键字 k，在集合 S 中寻找元素 x 使得 x->key=k，并返回 x；若没有 x 满足该条件，则返回 nil

一些关于全序集的操作，例如链表：

数据结构中的顺序一般由关键字 key 的大小决定

- **Minimum(S)**: 给定全序集 S，返回最小元素
- **Maximum(S)**: 给定全序集 S，返回最大元素
- **Successor(S, x)**: 给定全序集 S 中的元素 x，返回比 x 大的第一个元素；若 x 是最大元素，则返回 nil
- **Predecessor(S, x)**: 给定全序集 S 中的元素 x，返回比 x 小的第一个元素；若 x 是最小元素，则返回 nil

## 4.2 直接映射表

所有的 key 构成了一个集合 K，并且 K 有全集 U={0, 1, 2,..., m-1}，假设这些 key 相互独立

建立一个表 T[0...m-1] 来表示一个动态集合 S，这个表可以表示为

$$T[k]=x,\ if\ x\in S \And\ x\to key=k$$

否则

$$T[k]=nil$$

1. Insert(S, x): T[x->key]=x
2. Delete(S, x): T[x->key]=nil
3. Search(S, k): return T[k]

所有这些操作的时间消耗为 $O(1)$，但是空间消耗非常的大，假设每个元素是一个长度为 32 的数，假设你只需要 10 个元素，也需要开辟一个 40G 的空间。

## 4.3 链接法

### 4.3.1 散列表基础

散列表，也称为哈希表，指用一个散列函数 $h$，将集合 $K$ 的全集 $U$ 映射到散列表 $T[0...m-1]$ 的槽位中，即

$$h:U\to\{0,1,...,,m-1\}$$

此时散列表可以表示为

$$T[h(k)]=x,\ if\ x\in S \And\ x\to key=k$$

否则

$$T[h(k)]=nil$$

由于散列表的大小 $m$ 要比 $\left | U \right | $ 小得多，因此一定存在两个互相独立的 key 映射到表中的同一个槽位，把这种情况称为`碰撞`

可以简单地为每一个槽创建一个链表，并且把发生碰撞的元素放入同一个链表，这种方法叫做`链接法`。

### 4.3.2 简单均匀散列

当所有元素都映射到了散列表的同一个槽，将是非常糟糕的，因为你将浪费大部分空间同时使得各种的速度变慢，时间消耗为 $O(n)$。在最坏情况下，有很多数据结构比散列表工作得更好，但是散列表的平均时间消耗仍然是最好的。

假设存在一个理想的散列函数 $h$，使得 $\forall x \in S$，$x\to k$ 能均匀地映射到大小为 $m$ 的散列表 $T$ 的所有槽中，其中每个 $key$ 与已经存在于表中的 $key$ 相互独立。

$$\Pr(h(k)=i)=\frac{1}{m},i\in\{0,1,...,,m-1\}$$

定义一个存放 $n$ 个键，有 $m$ 个槽的散列表，定义它的装载因子为 $\alpha=n/m$，$\alpha$ 表示这个散列表的平均装载量。

假设寻找一个并不在表内的键，则时间消耗包括计算散列值和查找链表。计算散列值的时间消耗为 $\Theta(1)$，每个链表的平均长度为 $\alpha$，所以查找链表的时间消耗为 $\Theta(\alpha)$，总的时间消耗为 $\Theta(1+\alpha)$，当 $n=O(m)$时，$O(\alpha)=O(1)$，此时搜索时间消耗为常数 $O(1)$

**定理**：在简单均匀散列的假设下，对于用链接法解决冲突的散列表，一次成功查找所需的平均时间为 $\Theta(1+\alpha)$

### 4.3.3 两种散列函数

一个好的散列函数要满足以下几点：

- 可以让所有元素均匀地分配到散列表中
- 不同的键集合不影响其分配的均匀性

#### 除法散列法

$$h(k)=k\ mod\ m$$

- 不要选择一个太小的 $m$ 来做除数

$e.g.$ 选择 $m=2$ 同时所有 $k$ 都是偶数

- 不要选择偶数 $m$ 来做除数

$e.g.$ 选择 $m=16$ 同时所有 $k$ 都是偶数

因为偶数除以偶数余数也是偶数，此时散列表中所有的奇数位永远为空

- 不要选择 $m=2^r$ 来做除数

此时 $h(k)$ 就是 $k$ 的 $r$ 个最低位数字

最好的方法是使用质数作为除数，同时该质数需要远离 $2$ 和 $10$ 的幂

#### 乘法散列法

假设 $m=2^r$，以及计算机的一个字的长度是 $w$ 位

$$h(k)=(A\cdot k\ mod\ 2^w)rsh(w-r)$$

首先将 $k$ 乘以一个大于 $2^{w-1}$ 且小于 $2^{w}$ 的奇数 $A$，然后对 $2^w$ 取模，然后右移 $w-r$ 位

- 不要选择太接近 $2^r$ 的值做为 $A$

## 4.4 开放寻址法

开放寻址法不使用链表解决碰撞，它通过不断地散列直到找到一个空位置

$$h:U\times\{0,1,...,,m-1\}\to\{0,1,...,,m-1\}$$

定义域是全集 $U$ 与探查序列（第几次散列）$\{0,1,...,,m-1\}$ 的笛卡尔积，陪域是散列表的槽位

探查序列是一个算术序列

开放寻址最终会被填满，因此要保证 $n\leqslant m$，这样散列表才不会溢出

### 4.4.1 线性探查序列

$$h(k,i)=(h'(k)+i)\ mod\ m$$

$h'(k)$ 称为辅助散列函数

当一个槽被占用时，这个函数会递归地走到下一个槽并检查

**一次群集问题**：散列表可能出现长度为 $m'$ 的连续区域，这片连续区域都被占满，这使得每次插入操作都会遍历这片连续区域，将显著增加时间消耗

为了解决这个问题，可以通过修改成以下函数来缓解

$$h(k,i)=(h_1(k)+i\cdot h_2(k))\ mod\ m$$

通常取 $m=2^r$ 同时 $h_2(k)$ 为奇数

### 4.4.2 时间消耗计算

假设探查序列能遍历序列 $<0,1,...,m-1>$ 中的所有值，遍历的过程是 $<0,1,...,m-1>$ 的一个排列，每个键都均等地有 $m!$ 种探查序列，并且每个键是相互独立的。

**定理**：当 $\alpha<1$时，预期的探查次数最多不超过 $1/(1-\alpha)$

如果有 $n$ 个元素装在大小为 $m$ 的散列表里

假设这次是失败搜索，因此 $i=0$ 时一定会撞上一个非空槽，那之后 $i=1$ 时的搜索撞上一个非空槽的概率为 $n/m$，$i=2$ 时的搜索撞上一个非空槽的概率为 $(n-1)/(m-1)$，则有 $i=k$ 时的搜索撞上一个非空槽的概率为

$$\Pr(i=k\ \text{时撞上非空槽})=\frac{n-k-1}{m-k-1}$$

且有

$$\frac{n-k-1}{m-k-1}<\frac{n}{m}=\alpha$$

求碰撞次数的期望是

$$E[collision]=1+\frac{n}{m}(1+\frac{n-1}{m-1}(1+\frac{n-2}{m-2}(...(1+\frac{1}{m-n}))))$$

$$\leqslant 1+\alpha(1+\alpha(1+\alpha(...(1+\alpha))))$$

$$= 1+\alpha+\alpha^2+\alpha^3+...$$

$$= \sum_{i=0}^{\infty}\alpha^i$$

$$= \frac{1}{1-\alpha}$$

这意味着探查这个表的平均时间消耗是 $O(1)$

## 4.5 全域散列和完全散列

### 4.5.1 散列的根本缺陷

对于所有散列函数，都存在一个不好的键集，使得所有键都会散列映射到同一个槽。问题的关键是，随机选择散列函数，并且这个过程与键集独立。这个方法的名字叫做全域散列。

### 4.5.2 全域散列

设 $U$ 是键的全域，$H$ 为哈希函数的有限集，哈希函数将 $U$ 映射到集合$\{0,1,...,m-1\}$。如果满足对于所有的键对，使得所有的键是互异的，则称 $H$ 是全域的。

$$\left|\{h\in H:h(x)=h(y)\}\right|=\frac{\left|H\right|}{m}$$

如果散列函数 $h$ 是随机地从函数集 $H$ 中选择的，那么 $x$ 和 $y$ 碰撞的几率是 $1/m$

**定理**：从函数集 $H$ 中随机选择散列函数 $h$，假设要将 $n$ 个键放进 $T$ 表的 $m$ 个槽里。对于给定的键 $x$，它发生碰撞的期望次数

$$E[collision]<n/m=\alpha$$

**证明**：设 $C_x$ 为一个随机变量，它表示散列表 $T$ 里的键与 $x$ 发生碰撞的总次数

$$C_{xy}=\left\{\begin{align}
 & 1\quad if\ h(x)=h(y)\nonumber \\  
 & 0\quad otherwise\nonumber
\end{align}\right. $$

易得，$E[C_{xy}]=1/m$

$$C_{x}=\sum_{y\in T-\{x\}}C_{xy}$$

求 $C_{x}$ 的期望

$$\begin{equation}\begin{split}
E[C_{x}]&=E\left[\sum_{y\in T-\{x\}}C_{xy}\right]\\
&=\sum_{y\in T-\{x\}}E[C_{xy}]\\
&=\sum_{y\in T-\{x\}}\frac{1}{m}\\
&=\frac{n-1}{m}
\end{split}\end{equation}$$

#### 构造全域散列

当 $m$ 为质数时，把全域里的键 $k$ 分解成 $r+1$ 位，把 $k$ 看作一个序列

$$k=<k_0,k_1,...,k_r>,\ 0\leqslant k_i\leqslant m-1$$

即把 $k$ 用 $m$ 进制来表示

随机地选择一个数 $a$，同样的也看成 $m$ 进制数

$$a=<a_0,a_1,...,a_r>,\ 0\leqslant a_i\leqslant m-1$$

对于 $a$ 的每一位都找到一个散列函数 $h$

$$h_{a}(k)=(\sum_{i=0}^{r}a_i\cdot k_i)\ mod\ m$$

散列函数集 $H$ 的势为 $m^{r+1}$

**定理**：散列函数集 $H$ 是全域的

**证明**：假设有两个互异的键 $x$，$y$，其中

$$x=<x_0,x_1,...,x_r>,\ 0\leqslant x_i\leqslant m-1$$

$$y=<y_0,y_1,...,y_r>,\ 0\leqslant y_i\leqslant m-1$$

$x$ 与 $y$ 互异意味着至少有一位满足 $x_i\ne y_i$

假设在第 $0$ 位不相等，此时有多少个 $h_a\in H$ 使得 $x$ 与 $y$ 碰撞？

如果发生碰撞，则有

$$h_a(x)=h_a(y)$$

即

$$\sum_{i=0}^{r}a_i\cdot x_i\equiv\sum_{i=0}^{r}a_i\cdot y_i\ (mod\ m)$$

$$\sum_{i=0}^{r}a_i\cdot (x_i-y_i)\equiv 0\ (mod\ m)$$

$$a_0(x_0-y_0)+\sum_{i=1}^{r}a_i\cdot (x_i-y_i)\equiv 0\ (mod\ m)$$

$$a_0(x_0-y_0)\equiv-\sum_{i=1}^{r}a_i\cdot (x_i-y_i)\ (mod\ m)$$

`有限域理论`

存在一个质数 $m$，$Z_m$ 是整数对 $m$ 取余后的整数的集合，对于任意 $z\in Z_m$，并且 $z\not\equiv 0$，存在唯一一个 $z^{-1}\in Z_m$，使得 $z^{-1}z\equiv 1\ (mod\ m)$

因为 $x_0\neq y_0$，所以存在 $(x_0-y_0)^{-1}$ 使得

$$a_0\equiv[-\sum_{i=1}^{r}a_i\cdot (x_i-y_i)](x_0-y_0)^{-1}\ (mod\ m)$$

可以看出，对于任意除 $a_0$ 以外的序列 $<a_1,...,a_r>$，有且仅有唯一的 $a_0$，使得 $x$ 与 $y$ 发生碰撞。

综上，当除 $a_i$ 以外的序列 $<a_0,...,a_{i-1},a_{i+1},...,a_r>$ 已被确定时，有且仅有一个 $a_i$ 使得 $x$ 与 $y$ 碰撞，这样的序列共有 $m^r$ 个。

因此，由 $a$ 确定的散列函数 $h_a$ 中，有 $m^r$ 个 $h_a\in H$ 使得 $x$ 与 $y$ 碰撞，即 $\frac{\left|H\right|}{m}$，所以用这种方式构造的散列函数集是全域的。

### 4.5.2 完全散列

给定 $n$ 个键，创建一个静态散列表，表的大小是 $m=O(n)$，使得在最坏情况下，查找的时间是 $O(1)$

1解决问题的关键是使用一个双级结构，并且在每一级使用全域散列，保证在第二级没有碰撞。

如果有 $n_i$ 个项同时被散列到第一级的槽 $i$，那么有 $m_i=n_i^2$ 个槽在二级散列表。

**定理**：如果把 $n$ 个键散列映射到 $m=n^2$ 个槽里，并且散列函数从全域散列函数集中随机挑选，此时碰撞次数的期望值 $E[collision]<\frac{1}{2}$

**证明**：对于两个给定的键 $x$ 和 $y$，经过散列函数 $h$ 散列后碰撞的概率为 $\frac{1}{m}=\frac{1}{n^2}$，一共有 $C_{n}^{2}$ 对这样的键。

因此碰撞的期望值为

$$E[collision]=C_{n}^{2}\cdot\frac{1}{n^2}=\frac{n(n-1)}{2n^2}<\frac{1}{2}$$

`Markov 不等式`

对于随机变量 $X\geqslant 0$

$$\Pr(X\geqslant t)\leqslant\frac{E[X]}{t}$$

**证明**：

$$\begin{equation}\begin{split}
E[X]&=\sum_{x=0}^{\infin}x\cdot\Pr(X=x)\\
&\geqslant\sum_{x=t}^{\infin}x\cdot\Pr(X=x)\nonumber\\
&\geqslant\sum_{x=t}^{\infin}t\cdot\Pr(X=x)\\
&=t\cdot\Pr(X\geqslant t)
\end{split}\end{equation}$$

**引理**：没有碰撞的概率

$$\Pr(no\ collisions)\geqslant\frac{1}{2}$$

**证明**：至少一次碰撞的概率为

$$\Pr(at\ least\ 1\ collision)\leqslant\frac{E[collision]}{1}<\frac{1}{2}$$

因此

$$\Pr(no\ collisions)=1-\Pr(at\ least\ 1\ collision)\geqslant\frac{1}{2}$$

即可以让 $x$ 和 $y$ 不碰撞的散列函数 $h$ 有半数以上
